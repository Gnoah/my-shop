"use strict";

define(['ably', 'shared_helper', 'async'], function(Ably, helper, async) {
	var exports = {},
		displayError = helper.displayError,
		utils = helper.Utils,
		mixin = utils.mixin,
		closeAndFinish = helper.closeAndFinish,
		monitorConnection = helper.monitorConnection,
		testOnAllTransports = helper.testOnAllTransports;

	exports.setupMessage = function(test) {
		test.expect(1);
		helper.setupApp(function(err) {
			if(err) {
				test.ok(false, displayError(err));
			} else {
				test.ok(true, 'setup app');
			}
			test.done();
		});
	};

	exports.test = function(test) {
		const realtimeOpts = {transports: ['comet', 'xhr_streaming'], log: {level: 4}};
		var realtime, rest = helper.AblyRest();
		var clientId = "test clientid";
		rest.auth.requestToken({ttl: 1, clientId: clientId}, null, function(err, tokenDetails) {
			if(err) {
				test.ok(false, displayError(err));
				closeAndFinish(test, realtime);
				return;
			}
			setTimeout(function() {
				realtime = helper.AblyRealtime(mixin(realtimeOpts, { token: tokenDetails.token, clientId: clientId }));
				realtime.connection.once('failed', function(stateChange){
					test.ok(true, 'Verify connection failed');
					test.equal(stateChange.reason.code, 40171, 'Verify correct failure code');
					realtime.close();
					test.done();
				});
				/* Note: ws transport indicates viability when websocket is
				* established, before realtime sends error response. So token error
				* goes through the same path as a connected transport, so goes to
				* disconnected first */
				utils.arrForEach(['connected', 'suspended'], function(state) {
					realtime.connection.on(state, function () {
						test.ok(false, 'State changed to ' + state + ', should have gone to failed');
						test.done();
						realtime.close();
					});
				});
			}, 100)
		});
	}

	return module.exports = helper.withTimeout(exports);
});
